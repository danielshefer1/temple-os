# ============================================================================
# TOOLCHAIN CONFIGURATION
# ============================================================================
CC      = i686-elf-gcc
AS      = nasm
LD      = i686-elf-ld
OBJCOPY = i686-elf-objcopy

# ============================================================================
# FLAGS
# ============================================================================
# Added -MMD -MP for header dependency tracking
# Fixed -I to include current directory
CFLAGS       = -m32 -nostdlib -nostartfiles -ffreestanding -Wall -Wextra -g -I. -MMD -MP
ASFLAGS_BIN  = -f bin
ASFLAGS_ELF  = -f elf32 -g
LDFLAGS      = -m elf_i386 -T linker.ld
QEMU_FLAGS = -m 4096 -serial stdio -drive format=raw,file=os.img \
             -d int,cpu_reset -D qemu.log -no-reboot -no-shutdown

# ============================================================================
# SOURCE FILES
# ============================================================================
C_SOURCES = bootstrapper.c paging.c E820.c print_text.c kernel.c
C_OBJECTS = $(C_SOURCES:.c=.o)
# Include dependency files generated by GCC
DEPS      = $(C_SOURCES:.c=.d)

ASM_SOURCES = stage3.asm
ASM_OBJECTS = $(ASM_SOURCES:.asm=.o)

KERNEL_OBJECTS = $(ASM_OBJECTS) $(C_OBJECTS)

# ============================================================================
# OUTPUT FILES
# ============================================================================
STAGE1_BIN   = boot.bin
STAGE2_BIN   = boot2.bin
KERNEL_ELF   = kernel.elf
PAYLOAD_BIN  = payload.bin
DISK_IMG     = os.img

# ============================================================================
# BUILD RULES
# ============================================================================

all: $(DISK_IMG)

-include $(DEPS)

# --- Link kernel ELF ---
$(KERNEL_ELF): $(KERNEL_OBJECTS) linker.ld
	@echo "üîó Linking $(KERNEL_ELF)..."
	$(LD) $(LDFLAGS) -o $@ $(KERNEL_OBJECTS)

# --- Compile C sources ---
%.o: %.c
	@echo "‚öôÔ∏è  Compiling $<..."
	$(CC) $(CFLAGS) -c $< -o $@

# --- Assemble stage 3 (ELF) ---
%.o: %.asm
	@echo "üíª Assembling $< (ELF)..."
	$(AS) $(ASFLAGS_ELF) $< -o $@

# --- Assemble stage 2 (binary) ---
$(STAGE2_BIN): stage2.asm
	@echo "üíæ Assembling Stage 2 (BIN)..."
	$(AS) $(ASFLAGS_BIN) $< -o $@

# --- Assemble stage 1 (MBR) ---
$(STAGE1_BIN): boot.asm
	@echo "üíæ Assembling Stage 1 (MBR)..."
	$(AS) $(ASFLAGS_BIN) $< -o $@

# --- Create disk image ---
$(DISK_IMG): $(STAGE1_BIN) $(STAGE2_BIN) $(KERNEL_ELF)
	@echo "üì¶ Creating disk image $(DISK_IMG)..."
	# Added --gap-fill 0x00 to ensure binary continuity
	$(OBJCOPY) -O binary --gap-fill 0x00 $(KERNEL_ELF) $(PAYLOAD_BIN)
	# Initialize a 1MB disk image with zeros
	dd if=/dev/zero of=$(DISK_IMG) bs=512 count=2048 2>/dev/null
	# Write MBR (Stage 1) to Sector 0
	dd if=$(STAGE1_BIN) of=$(DISK_IMG) bs=512 count=1 conv=notrunc 2>/dev/null
	# Write Stage 2 to Sector 1
	dd if=$(STAGE2_BIN) of=$(DISK_IMG) bs=512 seek=1 conv=notrunc 2>/dev/null
	# Write Kernel (Stage 3) to Sector 5
	dd if=$(PAYLOAD_BIN) of=$(DISK_IMG) bs=512 seek=5 conv=notrunc 2>/dev/null
	@echo "‚úÖ Disk image created successfully!"

# ============================================================================
# RUN & DEBUG TARGETS
# ============================================================================

run: $(DISK_IMG)
	qemu-system-i386 $(QEMU_FLAGS)

debug: $(DISK_IMG) $(KERNEL_ELF)
	@echo "üêõ Starting QEMU and GDB..."
	# Added a sleep to allow QEMU to initialize the GDB stub
	qemu-system-i386 $(QEMU_FLAGS) -s -S & \
	sleep 1; \
	gdb $(KERNEL_ELF) \
		-ex "target remote localhost:1234" \
		-ex "set architecture i386" \
		-ex "break kmain" \
		-ex "continue"

clean:
	rm -f $(C_OBJECTS) $(ASM_OBJECTS) $(DEPS) *.bin *.elf $(DISK_IMG)